概念：就代表程序出现的问题
所有的错误集合在一个叫**java.lang.Throwable**的类里面，它又分为**两**个类，一个是**Error**，它代表了**系统级别**的错误(属于严重问题)，表示系统出现问题，sun公司会把这些错误封装成Error对象，它是给sun公司自己用的，不是给程序员用的，因此我们不用管它，另外一个叫**Exception**,它叫做异常，代表程序可能出现的问题，我们通常会用Exception以及它的子类来封装程序出现的问题
Exception又分为**两**个类，一个会在运行是提示出现异常，叫做**RuntimeException，以及它的子类**，编译阶段不会出现异常提示，运行时出现的异常(如：数组索引越界异常)
另外一个表示其他异常，在编译阶段出现的异常：编译阶段就会出现异常提示的(如；日期解析异常)


#### 异常的作用
作用一：异常是用来查询bug的关键参考信息
作用二：异常可以作为方法内部的一种特殊返回值，以便通知调用者底层的执行情况

作用二详解：如果调用方法想让不符合条件时的反馈传递给调用处，就要抛出异常，而不是反馈给控制台，抛出异常 throw new RuntimeException，这样就会知道方法使用失败，选择自己悄悄处理或者是打印在控制台上
## **看异常技巧：从下往上看**


## 异常的处理方式
三种
###### 1.JVM默认的处理方案
把异常的名称，异常原因及异常出现的位置等信息输出在了控制台，或者程序停止执行，下面的代码不会再执行

###### 2.自己处理(捕获异常)
格式：
try {
可能出现异常的代码；
} catch(异常类名  变量名) {
异常的处理代码；
}
目的：当代码出现异常时，可以让程序继续往下执行
示范
![[Pasted image 20240613224758.png]]

#### 捕获异常灵魂四问
**灵魂一问：如果try中没有遇到问题，怎么执行？**
会把try里面的所有的代码全部执行
只有出现了异常才会执行catch

**灵魂二问：如果try中可能会遇到多个问题，怎么执行？**
会写多个catch与之对应
细节：如果我们要捕获多个异常，这些异常中如果存在父子关系，那么父类一定要写在下面
了解性内容：在JDK7之后，我们可以在catch中同时捕获多个异常，中间用|隔开，表示如果出现了A异常或者B异常的话，采取同一种处理方案


**灵魂三问：如果try中遇到的问题没有被捕获，怎么执行？**
相当于try。。。catch的代码白写了，最终还是会交给虚拟机进行处理


**灵魂四问：如果try中遇到了问题，那么try下面的其他代码还会执行吗？**
不会执行了，try中遇到问题，直接跳转到对应的catch，如果没有对应的catch与之匹配，则交给虚拟机处理



#### 异常中的常用方法
![[Pasted image 20240614125042.png]]用得最多的为第三个


### 抛出异常
抛出处理
目的：让该方法结束运行并告诉调用者出现了问题
两种方法
**throws**
写在方法定义处，表示声明一个异常告诉调用者，使用本方法可能会有哪些异常
public void 方法() throws 异常类名1，异常类名2.。。。{
。。。
}
编译时异常：必须要写
运行时异常：可以不写


**throw**
写在方法内，结束方法，手动抛出异常对象，交给调用者，方法中<span style="background:#affad1">下面的代码不再执行</span>了
public void 方法(){
throw new NullPointerException()；
}


#### 自定义异常
意义：为了让异常更加的见名知意
怎么做
首先建一个类，类名字时当前异常的名字加Exception比如
![[Pasted image 20240614221152.png]]
然后继承一个类，是编译时异常就继承Exception类(核心是提示程序员检查本地信息)，是运行时异常就继承RuntimeException(核心是表示由于参数错误而导致的问题)
然后给它搞上有参构造和无参构造，这样就行了
在对象里面就可以抛出我们自己创建的异常，甚至可以在括号里写上一些东西
![[Pasted image 20240614222144.png]]
每次都需要抛出异常，其实也可以用try。。。catch来处理，这里给出了一些简化代码的方法，能够在特定情况下(接上AutoCloseable接口)自动释放，(不要求掌握，了解即可)

![[Pasted image 20240616224425.png]]