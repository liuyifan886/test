泛型：是jdk5中引入的特性，可以在编译阶段约束操作的数据类型，并进行检查
泛型的格式：<数据类型>(就是集合后面尖括号)
![[Pasted image 20240502161914.png]]
注意：泛型只支持引用数据类型
可以把它比喻成一个看门的大爷，负责查看数据是否是要求中的内容
可以不添加泛型，虽然能存储各种各样的数据，比如int，integer甚至是对象，但是也会有坏处，根据多态的规则来说，这些数据(就算强转)无法使用子类的特有方法了
泛型的出现解决了这一问题，只要限制数据类型就可解决这个问题
总结为两个好处
- 统一数据类型
- 把运行时期的问题提前到了编译期间，避免了强制类型转换可能出现的异常，因为在编译阶段类型就能确定下来

拓展知识点：java中的泛型为伪泛型
虽然是只有固定的类型能进去，但是进去了之后还是会把内容当成object，只不过调用出来的时候会强转成原来的数据类型

泛型的擦除
在java文件里面有泛型而在class文件里泛型会消失，就因为它是伪泛型，只在编译过程中生效，而只在这里生效时因为老版本时没有泛型，如果要改那么老版本全部会失效，干脆在新版本时搞一个只在编译过程中生效的“门神”

细节:
- 泛型中不能写基本数据类型(因为基本数据类型无法转成object数据)
- 指定泛型的具体类型后，传递数据时，可以传入该类类型或者其子类类型(但一般不这么干)
- 如果不写泛型，类型默认是object



**泛型还可以在很多地方进行定义**
比如类后面(类后面)，方法上面(泛型方法)，接口前面(泛型接口)，也是为了限定数据类型
泛型类
使用场景：当一个类中，某个变量的数据类型不确定时，就可以定义带有泛型的类
![[Pasted image 20240502170018.png]]
不是用来记录数据的，是用来记录数据的类型的，一般都写成：T(type) , E(element) ,K(key) ,V(value)
演示
![[Pasted image 20240502173941.png]]
然后使用这个自己写好的集合给别人测试，别人写什么数据类型就是什么数据类型


**泛型方法**
方法中形参类型不确定时，可以使用类名后面定义的泛型<\E>
在一个类中只有一个方法的形参不确定，那么可以不用把泛型定义在类里面，而是定义在方法里
方法中形参类型不确定时：
- 方案一；使用类名后面定义的泛型(泛型类)，所有方法能用
- 方案二：在方法申明上定义自己的泛型(上面说的就是这个)，只有本方法能用


#### 格式举例
![[Pasted image 20240502180843.png]]
和泛型方法差不多，泛型写在最后一个修饰符的后面



### 泛型接口
格式
![[Pasted image 20240502181830.png]]

重点：如何使用一个带泛型的接口
- 方法1：实现类给出具体类型，就是直接再尖括号里写是什么类型，举例：本来List接口是一个泛型，直接在接口里写String，那么想往里面输其他数据类型的就会报错
- 方法2：实现类延续泛型，创建对象时再确定，就算在类后面也接一个泛型，延续下去