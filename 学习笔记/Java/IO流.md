作用：存储和读取数据的解决方案,用于读写文件中的数据(可以都写文件，或网络中的数据...)

与[[File]]的区别：File类只能对文件本身进行操作，不能都写文件里面储存的数据

#### IO流的分类
可通过流的方向或者操作文件类型来分类
![[Pasted image 20240616113714.png]]
纯文本文件就是Windows能打开且能读懂的


# 字节流
字节流下面又分为两个抽象类，InputStream和OutputStream，但是抽象类不能建对象，所以我们应该学习他们的子类，他们的子类分别是FileInputStream和FileOutputStream

##### FileOutputStream
操作本地的字节输入流，可以把程序中的数据写到本地文件中
#### 书写步骤：
##### 1.创建字节输出流对象
写出输出流 OutputStream
本地文件 file
FileOutputStream fos=new FileOutputStream(“指定文件的路径”)；

细节：
1.参数是字符串表示的路径或者是File对象都是可以的
2.如果文件不存在会创建一个新的文件，但是要保证父级路径是存在的
3.如果<span style="background:#ff4d4f">文件已经存在，则会清空文件</span>
#### 2.写数据
fos.write()；

细节：write方法的参数是整数，但是实际上写到本地文件中但是整数在ASCII上对应的字符
#### 3.释放资源
fos.close()；

细节:每次使用完成之后都要释放资源，不释放资源会被占用


#### 字节输出流写出数据的三种方式
![[Pasted image 20240616170041.png]]


#### 换行和续写
换行写一个换行符就行，系统不一样，换行符不一样
Windows是\\r\\n
Linux是\\n
Mac是\\r
![[Pasted image 20240616173247.png]]
![[Pasted image 20240616173825.png]]

## FileInputStream
操作本地文件的字节输入流，可以把本地文件中的数据读取到程序中来
操作步骤：还是那一出，先创建对象，然后使用方法，再释放资源
读数据是read，返回的是int类，想要看它是啥，可以强转char类
细节：
1.创建对象时，如果文件不存在，就直接报错，和输出流不一样，因为就算创建一个文件也没有数据，没有用
2.读取数据：一次读一个字节，读出来的是数据在ASCII上对应的数字，读到文件末尾了，read方法返回-1
read表示读取数据，而且是读取一个数据就移动一次指针，类似迭代器

read方法也有多种
![[Pasted image 20240616221405.png]]
细节，第二个方法读取之后会把数据返回数组，方法还有返回值，为<span style="background:#d3f8b6">读取数据的数量</span>
#### 循环读取数据
![[Pasted image 20240616182147.png]]


#### 为什么会有乱码
原因：
1.读取数据时未读完整个汉字，因为字节流一次只读一个字节，而汉字从UTF-8来说要占三个字节
2.编码方式和解码方式不一样，比如用UTF-8编码，用GBK解码

如何不产生乱码
1.不要用字节流读取文本文件
2.编码解码时使用同一个码表，同一个编码方式


#### Java中的编码，解码的方法
![[Pasted image 20240618125020.png]]
![[Pasted image 20240618125035.png]]
IDEA默认方式是UTF-8，eclipse是GBK



### 字符流
底层是字节流
![[Pasted image 20240618221224.png]]
特点：
输入流：一次读一个字节，遇到中文时，一次读多个字节
输出流：底层会把数据按照指定的编码方式进行编码，变成字节再写到文件中
使用场景：对于纯文本文件进行读写操作
当然和字节流一样，他也有两个抽象类Reader(字符输入流)，Writer(字符输出流),抽象类不能建对象，所以研究他们的子类。FileReader为Reader的子类，FileWriter是Writer的子类
![[Pasted image 20240618222411.png]]



#### FileReader
和字节流一样
**1.创建字符输入流对象**
![[Pasted image 20240618222547.png]]
**2.读取数据**
![[Pasted image 20240618222632.png]]**3.释放资源**
![[Pasted image 20240618222819.png]]

read方法细节
空参方法细节
![[Pasted image 20240618223453.png]]

有参方法细节
![[Pasted image 20240618224537.png]]




### FileWriter
![[Pasted image 20240619085549.png]]
默认关闭续写的啊，想要开启得手动开啊
规则用法注意事项和字节流大同小异啊

#### 字符流原理图
![[Pasted image 20240619092828.png]]


#### 字节流和字符流的使用场景
字节流：拷贝任意类型的文件
字符流：读取纯文本文件中的数据，往纯文本文件中写出数据


### 字节缓冲流
是优化版的字节流，高级流
分为BufferedinputStream(字节缓冲输入流)和BufferedOutStream(字节缓冲输出流)
原理：底层自带了长度为8192的缓冲区提高数据
![[Pasted image 20240620222250.png]]


### 字符缓冲流
分为BuffedReader(字符缓冲输入流)和BufferedWriter(字符缓冲输出流),原理也是：自带了长度为8192的缓冲区提高性能

该流特有方法
![[Pasted image 20240620223328.png]]
readLine和read方法原理类似，只不过这个返回null
![[Pasted image 20240620223457.png]]
不会读换行回车符，就是说不会换行

<span style="background:#d3f8b6">**跨行方法是这个类独有的**</span>
字符流的特有方法：flush()刷新缓冲区，和close方法不一样，这个只是刷新缓冲区，还能接着用这个流，close直接关闭流了



#### 转换流
![[Pasted image 20240623090224.png]]
归属于字符流，是一种高级类，是字符流和字节流之间的桥梁
作用：字节流想要使用字符流中的方法
其实原本还有一个功能是指定字符编码读取，但是因为JDK11后FileReader也添加了指定编码规则功能就废除了，FileWriter也是，但值得一提的是指定编码规则要用方法Charset.forName("编码规则名字")
![[Pasted image 20240623091838.png]]


#### 序列化流
![[Pasted image 20240623093351.png]]
##### 序列化流/对象操作输出流
可以把Java中的对象写到本地文件中
![[Pasted image 20240623093929.png]]
因为本身是高级流，所以构造方法要靠基本流

小细节：使用对象输出流将对象保存到文件时会出现NotSerializableException异常
解决方案：需要Javabean类实现Serializable接口

Serializable接口里面没有抽象方法，是标记型接口，一旦实现了这个接口，那么就表示当前的Student类可以被序列化


##### 反序列化流/对象操作输入流
可以把序列化到文件本地中的对象，读取到程序中来
![[Pasted image 20240623100808.png]]



#### 序列化流和反序列化流的使用细节
当你储存了一个对象之后，你又在JavaBean里添加了一些东西，这时你读取文件中的对象之后就会报错，这是因为JavaBean会读取里面的成员变量，静态变量，构造方法，成员方法来计算序列号，这个序列号也会跟着对象被储存在文件里，当JavaBean被修改后，序列号发生变化，和文件里的序列号不一样，就会报错，我们通常的解决方法是，在创建对象的时候直接定义一个固定的序列号
![[Pasted image 20240623102748.png]]

有对象属性不想序列化到本地，那就在前面添加一个关键字
transient：瞬态关键字
作用：不会把当前属性序列化到本地文件当中


#### 读写多个对象
因为在Java里面不可能只会有一个对象，而且代码也不是我们一个人写的，我们会把对象放入集合中，而且集合有序列号，也接上了Serializable接口，所以我们直接把集合放入文件中，然后读集合


#### 打印流
分类：打印流一般是指PrintStream(字节打印流)，PrintWriter(字符打印流)两个类

字节打印流
![[Pasted image 20240623113349.png]]
![[Pasted image 20240623113554.png]]
![[Pasted image 20240623115303.png]]
占位符啊，真是梦回c语言

字符打印流
字符流底层有缓冲区，想要自动刷新需要开启
构造方法和字节打印流差不多
![[Pasted image 20240623152041.png]]
成员方法也是
![[Pasted image 20240623152117.png]]
这个字符打印流和sout有着密切的联系
out就是一个静态变量，类型是printWriter
![[Pasted image 20240623155019.png]]


#### 压缩流/解压缩流
![[Pasted image 20240623155950.png]]

压缩本质是把数据写入压缩包，解压缩本质是把数据从压缩包里读取出来

##### 解压缩流
压缩包里每一个文件都是一个ZipEntry对象，解压的本质是把每一个ZipEntry对象按照层级拷贝到本地另一个文件夹中
详情看idea里的代码



#### 压缩流
压缩本质，把每一个(文件/文件夹)看成ZipEntry对象放到压缩包中
![[Pasted image 20240623212846.png]]  


#### Commons-io
是apache开源基金组织提供的一组有关IO操作的开源工具包
作用：提高IO流的开发效率


别人写的jar包就是别人写的类，那么该如何去使用呢
1.在项目中创建一个文件夹：lib
2.将jar包复制粘贴到lib文件夹
3.右键点击jar包，选择Add as Library->点击OK
4.在类中导包使用


Commons-io的常见方法
![[Pasted image 20240623222146.png]]
![[Pasted image 20240623222258.png]]


#### hutool
国人创建的一个工具包
内涵很多好用方法
有关IO流的好用方法
![[Pasted image 20240624093854.png]]