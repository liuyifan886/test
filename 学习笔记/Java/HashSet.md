无序，不重复，无索引
没有什么特殊方法，只需要研究底层原理即可
这个集合底层采用哈希表储存数据
哈希表是一种**对于增删改查数据性能都较好的结构****
**
哈希表组成
JDK8之前：数组+链表
JDK8之后：数组+链表+红黑树

哈希值
对象的整数表现形式
为什么要变成整数
因为它存储数据去数组不是简单的从0索引开始而是用一个公式
![[Pasted image 20240519093521.png]]
根据hashCode方法算出来的int类型的整数
该方法定义再object类中，所有方法都可以调用，默认使用地址值进行计算
一般情况下，会从写hashcode方法，利用对象内部的属性值计算
### 哈希值对象的哈希值特点
- 如果没有重写hashcode方法，不同对象计算出的哈希值是不同的
- 如果重写hashcode方法，不同的对象只要属性值相同，计算出的哈希值就是一样的
- 在小部分情况下，不同的属性值或者不同的地址值计算出来的哈希值也有可能一样(哈希碰撞)，有可能但是概率不高


底层原理
- 创建一个默认长度16，默认加载因子为0.75(意思是当数据占到数组0.75长度时扩容两倍)的数组，数组名table
- 根据元素的哈希值数组的长度计算出应存入的位置
- 判断当前位置是否为null，如果是null直接存入
- 如果位置不为null，表示有元素，则调用equals方法比较属性值
- 一样：不存          不一样：存入数据形成链表
- JDK8以前：新元素存入数组，老元素挂在新元素下面
- JDK8以后：新元素直接挂在老元素下面
- 当链表长度大于8而且数组长度大于等于64，链表自动形成红黑树从而提高查找效率
- 如果集合中存储的是自定义对象，必须要重写hashcode和equals方法



问题：hashset为什么没有索引
因为hashset是由数组链表红黑树组合而成的，不好定义数组

问题：hashset为什么存和取的顺序不一样
遍历从0索引开始，一个一个遍历里面的链表不能确定顺序

问题：hashset是利用什么机制保证数据去重的
hashcode方法来获取数据在数组中的位置，equals方法来比较
所以我们在存储自定义对象时一定要重写方法(非自定义类不需要重写，比如String这种Java自己已经写好了)